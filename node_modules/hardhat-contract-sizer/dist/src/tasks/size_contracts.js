"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_json_1 = require("../../package.json");
const chalk_1 = __importDefault(require("chalk"));
const cli_table3_1 = __importDefault(require("cli-table3"));
const fs_1 = __importDefault(require("fs"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
// see EIPs 170 and 3860 for more information
// https://eips.ethereum.org/EIPS/eip-170
// https://eips.ethereum.org/EIPS/eip-3860
const DEPLOYED_SIZE_LIMIT = 24576;
const INIT_SIZE_LIMIT = 49152;
const UNITS = { B: 1, kB: 1000, KiB: 1024 };
(0, config_1.task)('size-contracts', 'Output the size of compiled contracts')
    .addFlag('noCompile', "Don't compile before running this task")
    .setAction(async (args, hre) => {
    if (!args.noCompile) {
        await hre.run(task_names_1.TASK_COMPILE, { noSizeContracts: true });
    }
    const config = hre.config.contractSizer;
    if (!UNITS[config.unit]) {
        throw new plugins_1.HardhatPluginError(package_json_1.name, `Invalid unit: ${config.unit}`);
    }
    const formatSize = (size) => {
        const divisor = UNITS[config.unit];
        return (size / divisor).toFixed(3);
    };
    const outputData = [];
    const fullNames = await hre.artifacts.getAllFullyQualifiedNames();
    const outputPath = path_1.default.resolve(hre.config.paths.cache, '.hardhat_contract_sizer_output.json');
    const previousSizes = {};
    const previousInitSizes = {};
    if (fs_1.default.existsSync(outputPath)) {
        const previousOutput = JSON.parse((await fs_1.default.promises.readFile(outputPath)).toString());
        previousOutput.forEach((el) => {
            previousSizes[el.fullName] = el.deploySize;
            previousInitSizes[el.fullName] = el.initSize;
        });
    }
    await Promise.all(fullNames.map(async (fullName) => {
        if (config.only.length && !config.only.some((m) => fullName.match(m)))
            return;
        if (config.except.length &&
            config.except.some((m) => fullName.match(m)))
            return;
        const { deployedBytecode, bytecode } = await hre.artifacts.readArtifact(fullName);
        const deploySize = deployedBytecode
            ? Buffer.from(deployedBytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2), 'hex').length
            : 0;
        const initSize = bytecode
            ? Buffer.from(bytecode.replace(/__\$\w*\$__/g, '0'.repeat(40)).slice(2), 'hex').length
            : 0;
        outputData.push({
            fullName,
            displayName: config.disambiguatePaths
                ? fullName
                : (fullName.split(':').pop() ?? ''),
            deploySize,
            previousDeploySize: previousSizes[fullName],
            initSize,
            previousInitSize: previousInitSizes[fullName],
        });
    }));
    if (config.alphaSort) {
        outputData.sort((a, b) => a.displayName.toUpperCase() > b.displayName.toUpperCase() ? 1 : -1);
    }
    else {
        outputData.sort((a, b) => a.deploySize - b.deploySize);
    }
    await fs_1.default.promises.writeFile(outputPath, JSON.stringify(outputData), {
        flag: 'w',
    });
    const table = new cli_table3_1.default({
        style: { head: [], border: [], 'padding-left': 2, 'padding-right': 2 },
        chars: {
            mid: '·',
            'top-mid': '|',
            'left-mid': ' ·',
            'mid-mid': '|',
            'right-mid': '·',
            left: ' |',
            'top-left': ' ·',
            'top-right': '·',
            'bottom-left': ' ·',
            'bottom-right': '·',
            middle: '·',
            top: '-',
            bottom: '-',
            'bottom-mid': '|',
        },
    });
    const compiler = hre.config.solidity.compilers[0];
    table.push([
        {
            content: chalk_1.default.gray(`Solc version: ${compiler.version}`),
        },
        {
            content: chalk_1.default.gray(`Optimizer enabled: ${compiler.settings.optimizer.enabled}`),
        },
        {
            content: chalk_1.default.gray(`Runs: ${compiler.settings.optimizer.runs}`),
        },
    ]);
    table.push([
        {
            content: chalk_1.default.bold('Contract Name'),
        },
        {
            content: chalk_1.default.bold(`Deployed size (${config.unit}) (change)`),
        },
        {
            content: chalk_1.default.bold(`Initcode size (${config.unit}) (change)`),
        },
    ]);
    let oversizedContracts = 0;
    for (let item of outputData) {
        if (item.deploySize === 0 && item.initSize === 0) {
            continue;
        }
        let deploySize = formatSize(item.deploySize);
        let initSize = formatSize(item.initSize);
        if (item.deploySize > DEPLOYED_SIZE_LIMIT ||
            item.initSize > INIT_SIZE_LIMIT) {
            oversizedContracts++;
        }
        if (item.deploySize > DEPLOYED_SIZE_LIMIT) {
            deploySize = chalk_1.default.red.bold(deploySize);
        }
        else if (item.deploySize > DEPLOYED_SIZE_LIMIT * 0.9) {
            deploySize = chalk_1.default.yellow.bold(deploySize);
        }
        if (item.initSize > INIT_SIZE_LIMIT) {
            initSize = chalk_1.default.red.bold(initSize);
        }
        else if (item.initSize > INIT_SIZE_LIMIT * 0.9) {
            initSize = chalk_1.default.yellow.bold(initSize);
        }
        let deployDiff = '';
        let initDiff = '';
        if (item.previousDeploySize) {
            if (item.deploySize < item.previousDeploySize) {
                deployDiff = chalk_1.default.green(`-${formatSize(item.previousDeploySize - item.deploySize)}`);
            }
            else if (item.deploySize > item.previousDeploySize) {
                deployDiff = chalk_1.default.red(`+${formatSize(item.deploySize - item.previousDeploySize)}`);
            }
            else {
                deployDiff = chalk_1.default.gray(formatSize(0));
            }
        }
        if (item.previousInitSize) {
            if (item.initSize < item.previousInitSize) {
                initDiff = chalk_1.default.green(`-${formatSize(item.previousInitSize - item.initSize)}`);
            }
            else if (item.initSize > item.previousInitSize) {
                initDiff = chalk_1.default.red(`+${formatSize(item.initSize - item.previousInitSize)}`);
            }
            else {
                initDiff = chalk_1.default.gray(formatSize(0));
            }
        }
        table.push([
            { content: item.displayName },
            { content: `${deploySize} (${deployDiff})`, hAlign: 'right' },
            { content: `${initSize} (${initDiff})`, hAlign: 'right' },
        ]);
    }
    console.log(table.toString());
    if (config.outputFile)
        fs_1.default.writeFileSync(config.outputFile, `${(0, strip_ansi_1.default)(table.toString())}\n`);
    if (oversizedContracts > 0) {
        console.log();
        const message = `Warning: ${oversizedContracts} contracts exceed the size limit for mainnet deployment (${formatSize(DEPLOYED_SIZE_LIMIT)} ${config.unit} deployed, ${formatSize(INIT_SIZE_LIMIT)} ${config.unit} init).`;
        if (config.strict) {
            throw new plugins_1.HardhatPluginError(package_json_1.name, message);
        }
        else {
            console.log(chalk_1.default.red(message));
        }
    }
});
